
# 🏷️ 预备工作

❓ 当我们在系统中创建一个空文件时，这个文件要不要占据磁盘的空间（注意是空文件哟）

答案：当然是要占据磁盘的空间的，文件不仅只包括内容，还有它的属性呀，就是创建时间，用户是谁，修改时间之类的，所以即便这个文件是一个空文件，但它也有属性呀，所以也要占据空间

> 文件 = 内容 + 属性

## 📌 所有对文件的操作，无非就是两种：
1. 对内容的操作
2. 对属性的操作

## 📌 文件的内容是数据，文件的属性也是数据，我们存储文件必须把文件的内容和属性都存储

## 📌 我们如果要访问一个文件，我们要先打开它，问题来了 ❓：
1. 我们指的是谁？
2. 文件打开前是什么意思?
3. 文件打开之后是什么意思？

- 1. 这里的我们指的是==进程==，不是你自己哈。比如你在你写的程序之中写了 `fopen` 这个函数来打开一个文件，但是只有这个程序编译形成可执行程序之后才可以去执行这个`fopen`的操作，一个被加载到内存的可执行程序叫什么呀？—— 不就是==进程==吗？
- 2. 文件打开之前，就是==一个普通的磁盘文件==，是在磁盘上面的
- 3. 打开后这个文件，其实上是将这个文件加载到内存 

## 📌 一个进程可以打开多个文件吗？ 多个进程可以打开多个文件吗？

- 一个进程可以打开多个文件，多个进程也可以打开多个文件

加载到内存中被打开的文件，可能存在多个

文件本来是在磁盘中的，将文件从磁盘中加载到内存里一定要涉及到访问磁盘设备，但是磁盘是外设，把磁盘里的数据加载到内存中的这个工作只能是由操作系统来做

## 📌 操作系统在运行的时候可能会打开很多个文件，那么操作系统是如果来管理这些文件的呢？

由我们之前学习的知识可知，如果涉及到管理，一般的步骤是：**先描述在组织**

### ✏️先描述：
一个文件要被打开，一定要在内核中形成被打开的文件对象
类似这样：
```c
struct xxxx
{
	// 文件的属性
	xxxxx
	struct xxxx *next;
};
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/131ab7a0cf11443db4ba52de596aa4f6.png)


## 📌 文件按照是否被打开分为：被打开的文件和没有被打开的文件


被打开的文件是存放在内存中的，没有被打开的文件是存放在磁盘中的



## 📌 本次学习的目的是：研究进程和打开文件之间的关系








# 🏷️ 复习一下常见的 C 的文件接口

## 📌 材料准备：

我们需要：``test.c`` , `Makefile`

### Makefile:
```c
myfile:myfile.c

	gcc -o $@ $^ 

.PHONY:clean

clean:

	rm -f myfile
```

### test.c

```c
#include <stdio.h>

int main()
{
    // "w": 按照写的方式来打开文件，如果文件不存在就创建
    FILE *fd = fopen("log.txt", "w");
    if (fd == NULL)
    {
        perror("fopen");
        return 1;
    }
	fclose(fd);  // 关闭文件
    return 0;
}
```

1. `FILE *fd = fopen("log.txt", "w");`
   这行代码调用了C标准库函数`fopen`，尝试以写入模式（"w"）打开名为`log.txt`的文件。如果文件不存在，`fopen`会尝试创建它。`fopen`函数返回一个指向`FILE`对象的指针，这个对象包含了所有与文件操作相关的信息。这个指针被存储在变量`fd`中，`fd`是一个指向`FILE`类型的指针。

2. `if (fd == NULL) {`
   这行代码检查`fopen`是否成功打开了文件。如果`fopen`不能打开文件（可能是因为文件不存在且没有权限创建，或者磁盘空间已满等原因），它会返回`NULL`。因此，这个`if`语句检查`fd`是否为`NULL`。

3. `perror("fopen");`
   如果`fd`是`NULL`，这意味着`fopen`函数失败了。在这种情况下，`perror`函数被调用来打印一条错误消息。`perror`函数的第一个参数是一个字符串，后面跟着一个冒号和一个空格。这个字符串是用户提供的，用来标识错误消息的来源。在这个例子中，字符串是`"fopen"`。`perror`会将这个字符串与`errno`全局变量中存储的错误代码相结合，`errno`是在尝试打开文件时由`fopen`设置的。然后，`perror`将打印出相应的错误消息到标准错误输出（通常是你的控制台或终端）。

4. `return 1;`
   如果文件打开失败，函数返回`1`。这是一种约定，表示函数因为遇到错误而提前终止。返回值`1`通常表示错误或异常状态，而返回`0`通常表示成功。

运行上面👆🏻的代码，`./mytest` ，可以发现我们的当前工作目录中已经出现了`log.txt` 这个文件。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b22a3ec3b4d34703b5c4a81528531b43.png)


**向这个文件中写入内容** 

```c    // 向这个文件中写入内容
    const char *msg = "hello linux file\n";
    int cnt = 10; 
    while(cnt)
    {
        fputs(msg, fd);
        cnt--;
    }

```

`fputs` 是 C 语言标准库中的一个函数，用于将一个字符串写入到文件中。这个函数声明在 `<stdio.h>` 头文件中，其原型如下：

```c
int fputs(const char *str, FILE *stream);
```

**整体代码**
```c
// myfile.c

#include <stdio.h>

int main()
{
    // "w": 按照写的方式来打开文件，如果文件不存在就创建
    FILE *fd = fopen("log.txt", "w");
    if (fd == NULL)
    {
        perror("fopen");
        return 1;
    }

        // 向这个文件中写入内容
        const char *msg = "hello linux file\n";
        int cnt = 10;
        while(cnt)
        {
            fputs(msg, fd);
            cnt--;
        }
    
    fclose(fd);
    return 0;
}
```

运行上面的代码之后我们可以放心 log.txt 中已经被写入了内容。


> 注意：以 "w" 的方式打开这个文件，会覆盖掉这个文件之前的内容。只要你以"w"的方式打开了，无论你做没做修改，之前的文件的内容都会被清空。
> 我们如果要清空一个文件的内容，可以使用命令：`> 文件名` ， 比如：`> log.txt` 。`>` 是重定向，这里由于没有任何的前置操作，所以会被我们的 shell 解释成： 首先我们要重定向，就要先把这个文件给打开，但是由于没有前置的命名，所以最后又关闭这个文件，但是默认是以写的方式来打开这个文件的，所以这个文件的内容被清空了。

**除了 “w”的方式来写入，我们还可以使用“a”方式来写入，代码如下：

```c
#include <stdio.h>

int main()
{
    // "w": 按照写的方式来打开文件，如果文件不存在就创建
    FILE *fd = fopen("log.txt", "a"); /////////////////////// 这里 a 方式
    if (fd == NULL)
    {
        perror("fopen");
        return 1;
    }

        // 向这个文件中写入内容
    const char *msg = "message text";
    fputs(msg,fd);
    fclose(fd);
    return 0;
}
```

`a` 方式也是写入，和 `w` 方式的区别是：`a` 方式不会删除之前的内容，它是从文件的结尾处开始写入，即：==追加，不清空==

> 我们上面说的 `>` :是输出重定向，使用 `> log.txt` 会删除这个`log.txt` 之前的内容，我们也可以使用 `>>` :这个是追加重定向，使用`>> log.txtt` 不会删除`log.txt` 之前的内容而是追加
> 



# 🏷️ 认识系统接口，操作文件

 一个进程是通过操作系统来打开文件的，所以操作系统一定会提供相应的系统调用接口，我们学习的 c语言的文件相关的函数`fopen`,`fclose` 之类的。底层一定是封装了系统的调用接口的 

## 📌 认识系统调用接口：open

在Linux系统中，`open` 系统调用用于打开或创建一个文件，并返回一个文件描述符，该文件描述符用于后续的文件操作。以下是对 `open` 系统调用的详细解释：

### 头文件

要使用 `open` 系统调用，你需要包含以下头文件：

```c
#include <fcntl.h>
```

`fcntl.h` 头文件包含了文件控制选项，包括 `open` 系统调用的定义。

### 函数原型

`open` 系统调用的函数原型如下：

```c
int open(const char *pathname, int flags);
```

在Linux中，`open` 系统调用还有一个额外的参数 `mode`，用于设置新创建文件的权限：

```c
int open(const char *pathname, int flags, mode_t mode);
```

### 返回值

- 如果 `open` 系统调用成功，它将返回一个非负的文件描述符（它返回的那个 int 类型的数，我们称之为文件描述符）。
- 如果调用失败，它将返回 `-1`，并设置全局变量 `errno` 以指示错误原因。

### 参数

1. `pathname`：一个指向文件名的指针。这个文件名可以是相对路径或绝对路径。

2. `flags`：一个标志位，用于指定文件打开的方式。常见的标志位包括：
   - `O_RDONLY`：以只读方式打开文件。(read only 缩写)
   - `O_WRONLY`：以只写方式打开文件。(write only)
   - `O_RDWR`：以读写方式打开文件。(read  and write)
   - `O_CREAT`：如果文件不存在，则创建一个新文件。（ creat ）
   - `O_TRUNC`：如果文件已存在且成功打开，则将文件长度截断为0。
   - `O_APPEND`：如果文件已存在，写入操作会在文件末尾追加数据。(appear end)
   - `O_EXCL`：与 `O_CREAT` 一起使用，如果文件已存在，则 `open` 调用失败。

3. `mode`（可选）：当创建新文件时，`mode` 参数指定了文件的权限模式。如果不需要创建新文件，这个参数通常被设置为0。`mode_t` 是一个数据类型，用于表示文件的权限模式。

### 用法

以下是使用 `open` 系统调用打开文件的示例：

```c
#include <fcntl.h>    // 包含 open 函数
#include <unistd.h>   // 包含 close 函数
#include <stdio.h>    // 包含 perror 和 printf 函数
#include <errno.h>    // 包含 errno 变量

int main() {
    int fd;
    // 打开文件，O_CREAT | O_WRONLY | O_TRUNC 表示创建文件，写入模式，截断文件
    fd = open("example.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (fd == -1) {
        perror("Error opening file");
        return 1;
    }

    // 进行文件操作，如写入数据
    // ...

    // 关闭文件
    if (close(fd) == -1) {
        perror("Error closing file");
        return 1;
    }

    return 0;
}
```

在这个示例中：

1. 使用 `open` 以写入模式打开（或创建）名为 `example.txt` 的文件。如果文件不存在，则创建它，并设置文件权限为 `0644`（即只有所有者可以写入）。
2. 检查 `open` 调用是否成功。如果失败，使用 `perror` 打印错误消息并返回 `1`。
3. 如果 `open` 成功，返回的文件描述符 `fd` 用于后续的文件操作。
4. 使用 `close` 系统调用关闭文件，并检查是否成功关闭。




# 🏷️ 尝试理解文件，打通语言和系统关于文件的部分
