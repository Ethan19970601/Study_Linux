# 🏷️ 进程创建

## 📌 fork  函数

``fork`` 函数的作用是用来创建一个子进程的，它的头文件是：``include <unistd.h>`` ，它没有参数，返回值是：``pid_t`` 。
```c++
#include <unistd.h>

pid_t fork(void);

//返回值：自进程中返回0，父进程返回子进程id，出错返回-1
```

``fork`` 函数返回的时候，如果是**父进程** 它就返回子进程的``pid``，如果是**子进程** 它就返回``0``。

``fork`` 有==两个== 返回值。

进程调用fork，当控制转移到内核中的fork代码后，内核做：

- 分配新的内存块和内核数据结构给子进程
	(就是创建子进程的 pcb, 地址空间，页表 构建映射关系)
	
- 将父进程部分数据结构内容拷贝至子进程
	(就是用父进程对应的一些字段来初始化子进程，所以页表才会指向同一个地址 )
	
- 添加子进程到系统进程列表当中

- fork返回，开始调度器调度


## 📌 fork 函数使用

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // 包含fork()和sleep()的定义

int main(void)
{
    pid_t pid; // 声明一个pid_t类型的变量来存储fork()的返回值

    // 打印当前（父）进程的PID
    printf("Before: pid is %d\n", getpid());

    // 调用fork()创建子进程
    if ((pid = fork()) == -1)
    {
        // 如果fork()失败，则打印错误信息并退出程序
        perror("fork()");
        exit(1);
    }

    // 注意：从这一点开始，代码将同时在父进程和子进程中执行

    // 打印当前进程的PID和fork()的返回值
    // 在父进程中，这将显示父进程的PID和子进程的PID
    // 在子进程中，这将显示子进程的PID和0（因为fork()在子进程中返回0）
    printf("After: pid is %d, fork return %d\n", getpid(), pid);

    // 父进程将执行sleep(1)，即暂停执行1秒
    // 子进程也会执行到这里，但由于没有更多的代码要执行（并且没有等待父进程的sleep完成），
    // 子进程通常会立即退出。然而，由于输出缓冲区的存在，子进程的输出可能会稍后出现，
    // 或者在某些情况下可能与父进程的输出混合。
    sleep(1);

    // 注意：这里没有针对子进程的特定退出代码，因为当子进程执行到这里时，
    // 它已经完成了main函数中的所有代码，并将正常退出。父进程也将继续执行到这里，
    // 但由于sleep(1)之后没有更多的代码，父进程也将正常退出。

    return 0; // 父进程和子进程都将返回0，但它们的返回状态对彼此是独立的。
}
```

所以运行的结果如下：

root@localhost linux# ./a.out
Before: pid is 43676
After:pid is 43676, fork return 43677
After:pid is 43677, fork return 0

这里看到了三行输出，一行before，两行after。进程43676先打印before消息，然后它有打印after。另一个after
消息有43677打印的。注意到进程43677没有打印before，为什么呢？
因为fork之前父进程独立执行，fork之后，父子两个执行流分别执行。注意，fork之后，谁先执行完全由调度器
决定。


## 📌 写时拷贝

通常，父子代码共享，父子再不写入时，数据也是共享的，当任意一方试图写入，便以写时拷贝的方式各自一份副
本。具体见下图:
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3a9303356e4d41b88d6bc697507c4b60.png)


**❓ 当父进程形成子进程之后，子进程写入，会发生写时拷贝 重新申请空间，进行拷贝，修改页表，我们的问题是：写时拷贝发生在什么时候？** 

父进程在创建子进程的时候，首先会将自己的读写权限修改为==**只读**==，然后才创建子进程

但是用户并不知道上面的过程，用户可能在未来的某个时刻对某一批数据进行写入，一旦你开始写入，页表转化会因为权限问题而出错，**这个时候操作系统介入**, 操作系统会先进行一个判断，如下：
1. 如果你要写入的数据是在代码段(代码段的权限为：只读)，那就是真的出错了。
2. 如果你要写入的数据是在数据段(数据段的权限为：读写),那不是真正的出错，触发我们进行重新申请内存拷贝内容的策略机制

通过这种触发异常的方式让操作系统进行写时拷贝，写时拷贝完成之后再把对应的页表映射条目改成读写，然后就可以进行正常的访问了，没有写入的依旧是只读的

**❓ 当父进程形成子进程之后，子进程写入，会重新申请空间，那为什么要进行拷贝呢（为啥要把原始的数据在拷贝一份呢）？**

如果你只是想要修改某个变量的名字，那我们可以拷贝原有的代码，在原有代码的基础上进行修改而不用从头开始
 写代码。


## 📌 fork常规用法

- 一个父进程希望复制自己，使父子进程同时执行不同的代码段。例如，父进程等待客户端请求，生成子
进程来处理请求。
- 一个进程要执行一个不同的程序。例如子进程从fork返回后，调用exec函数。

## 📌 fork调用失败的原因 

- 系统中有太多的进程
- 实际用户的进程数超过了限制


