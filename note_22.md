
# 🏷️ 预备工作

❓ 当我们在系统中创建一个空文件时，这个文件要不要占据磁盘的空间（注意是空文件哟）

答案：当然是要占据磁盘的空间的，文件不仅只包括内容，还有它的属性呀，就是创建时间，用户是谁，修改时间之类的，所以即便这个文件是一个空文件，但它也有属性呀，所以也要占据空间

> 文件 = 内容 + 属性

## 📌 所有对文件的操作，无非就是两种：
1. 对内容的操作
2. 对属性的操作

## 📌 文件的内容是数据，文件的属性也是数据，我们存储文件必须把文件的内容和属性都存储

## 📌 我们如果要访问一个文件，我们要先打开它，问题来了 ❓：
1. 我们指的是谁？
2. 文件打开前是什么意思?
3. 文件打开之后是什么意思？

- 1. 这里的我们指的是==进程==，不是你自己哈。比如你在你写的程序之中写了 `fopen` 这个函数来打开一个文件，但是只有这个程序编译形成可执行程序之后才可以去执行这个`fopen`的操作，一个被加载到内存的可执行程序叫什么呀？—— 不就是==进程==吗？
- 2. 文件打开之前，就是==一个普通的磁盘文件==，是在磁盘上面的
- 3. 打开后这个文件，其实上是将这个文件加载到内存 

## 📌 一个进程可以打开多个文件吗？ 多个进程可以打开多个文件吗？

- 一个进程可以打开多个文件，多个进程也可以打开多个文件

加载到内存中被打开的文件，可能存在多个

文件本来是在磁盘中的，将文件从磁盘中加载到内存里一定要涉及到访问磁盘设备，但是磁盘是外设，把磁盘里的数据加载到内存中的这个工作只能是由操作系统来做

## 📌 操作系统在运行的时候可能会打开很多个文件，那么操作系统是如果来管理这些文件的呢？

由我们之前学习的知识可知，如果涉及到管理，一般的步骤是：**先描述在组织**

### ✏️先描述：
一个文件要被打开，一定要在内核中形成被打开的文件对象
类似这样：
```c
struct xxxx
{
	// 文件的属性
	xxxxx
	struct xxxx *next;
};
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/131ab7a0cf11443db4ba52de596aa4f6.png)


## 📌 文件按照是否被打开分为：被打开的文件和没有被打开的文件


被打开的文件是存放在内存中的，没有被打开的文件是存放在磁盘中的



## 📌 本次学习的目的是：研究进程和打开文件之间的关系








# 🏷️ 复习一下常见的 C 的文件接口

## 📌 材料准备：

我们需要：``test.c`` , `Makefile`

### Makefile:
```c
myfile:myfile.c

	gcc -o $@ $^ 

.PHONY:clean

clean:

	rm -f myfile
```

### test.c

```c
#include <stdio.h>

int main()
{
    // "w": 按照写的方式来打开文件，如果文件不存在就创建
    FILE *fd = fopen("log.txt", "w");
    if (fd == NULL)
    {
        perror("fopen");
        return 1;
    }
	fclose(fd);  // 关闭文件
    return 0;
}
```

1. `FILE *fd = fopen("log.txt", "w");`
   这行代码调用了C标准库函数`fopen`，尝试以写入模式（"w"）打开名为`log.txt`的文件。如果文件不存在，`fopen`会尝试创建它。`fopen`函数返回一个指向`FILE`对象的指针，这个对象包含了所有与文件操作相关的信息。这个指针被存储在变量`fd`中，`fd`是一个指向`FILE`类型的指针。

2. `if (fd == NULL) {`
   这行代码检查`fopen`是否成功打开了文件。如果`fopen`不能打开文件（可能是因为文件不存在且没有权限创建，或者磁盘空间已满等原因），它会返回`NULL`。因此，这个`if`语句检查`fd`是否为`NULL`。

3. `perror("fopen");`
   如果`fd`是`NULL`，这意味着`fopen`函数失败了。在这种情况下，`perror`函数被调用来打印一条错误消息。`perror`函数的第一个参数是一个字符串，后面跟着一个冒号和一个空格。这个字符串是用户提供的，用来标识错误消息的来源。在这个例子中，字符串是`"fopen"`。`perror`会将这个字符串与`errno`全局变量中存储的错误代码相结合，`errno`是在尝试打开文件时由`fopen`设置的。然后，`perror`将打印出相应的错误消息到标准错误输出（通常是你的控制台或终端）。

4. `return 1;`
   如果文件打开失败，函数返回`1`。这是一种约定，表示函数因为遇到错误而提前终止。返回值`1`通常表示错误或异常状态，而返回`0`通常表示成功。

运行上面👆🏻的代码，`./mytest` ，可以发现我们的当前工作目录中已经出现了`log.txt` 这个文件。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b22a3ec3b4d34703b5c4a81528531b43.png)


**向这个文件中📃写入内容** 

```c    // 向这个文件中写入内容
    const char *msg = "hello linux file\n";
    int cnt = 10; 
    while(cnt)
    {
        fputs(msg, fd);
        cnt--;
    }

```

`fputs` 是 C 语言标准库中的一个函数，用于将一个字符串写入到文件中。这个函数声明在 `<stdio.h>` 头文件中，其原型如下：

```c
int fputs(const char *str, FILE *stream);
```









# 🏷️ 认识系统接口，操作文件








# 🏷️ 尝试理解文件，打通语言和系统关于文件的部分
